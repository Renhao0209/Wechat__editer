name: Release (Windows)

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag to publish (e.g. v0.3.1).'
        required: true
        default: 'v0.3.1'

permissions:
  contents: write

jobs:
  build-and-publish:
    runs-on: windows-latest

    env:
      RELEASE_TAG: ${{ github.event.inputs.tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: refs/tags/${{ env.RELEASE_TAG }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: npm

      - name: Verify tag matches package.json version
        shell: pwsh
        run: |
          $tag = "${{ env.RELEASE_TAG }}"
          if (-not $tag.StartsWith('v')) { throw "Tag must start with v, got: $tag" }
          $tagVersion = $tag.Substring(1)
          $pkg = Get-Content package.json -Raw | ConvertFrom-Json
          $pkgVersion = [string]$pkg.version
          Write-Host "Tag version: $tagVersion"
          Write-Host "Package version: $pkgVersion"
          if ($tagVersion -ne $pkgVersion) {
            throw "Tag version ($tagVersion) does not match package.json version ($pkgVersion)."
          }

      - name: Install dependencies
        run: npm ci

      - name: Build & publish (electron-builder)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: npm run build:desktop:publish

      - name: Update GitHub Release notes from release-notes/
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const tag = process.env.RELEASE_TAG;
            const version = tag.startsWith('v') ? tag.slice(1) : tag;

            const notesPath = path.join(process.env.GITHUB_WORKSPACE, 'release-notes', `v${version}.md`);
            let body = '';
            if (fs.existsSync(notesPath)) {
              body = fs.readFileSync(notesPath, 'utf8');
            } else {
              const changelogPath = path.join(process.env.GITHUB_WORKSPACE, 'CHANGELOG.md');
              if (fs.existsSync(changelogPath)) {
                body = fs.readFileSync(changelogPath, 'utf8');
              } else {
                body = `v${version}`;
              }
            }

            const { owner, repo } = context.repo;
            let releaseId = null;
            try {
              const rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
              releaseId = rel.data.id;
            } catch (e) {
              if (e?.status !== 404) throw e;
            }

            if (releaseId) {
              await github.rest.repos.updateRelease({
                owner,
                repo,
                release_id: releaseId,
                body,
              });
              core.info(`Updated release notes for ${tag}`);
            } else {
              await github.rest.repos.createRelease({
                owner,
                repo,
                tag_name: tag,
                name: tag,
                body,
              });
              core.info(`Created release for ${tag} with notes`);
            }
